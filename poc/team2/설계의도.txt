bug1 

## Bug1 - Multilingual Prompt-Injection Trap

### 목적
- 챗봇이 LLM(OpenAI) 응답을 그대로 신뢰하는 상황에서 **프롬프트 인젝션을 통해 서버 측 비밀(`/var/ctf/flag`)을 유출**할 수 있다는 점을 참가자에게 체험시킨다.
- 한국어/영어로는 절대 플래그를 받을 수 없도록 하여, **일본어나 중국어 등 CJK 스크립트**로 LLM을 조작해야만 문제가 풀리도록 만든다.
- 아래 아 한글이나 변형된 영어는 한국어/영어 범주에 포함되지 않고 **다른언어**로 간주한다.

### 설계 핵심
1. `backend/src/routes/chatbot.ts`의 `/chat` 엔드포인트가 OpenAI에 사용자의 입력을 그대로 전달한다.
2. LLM의 응답에 `flag` 혹은 `플래그` 문자열이 포함되면 서버가 직접 `/var/ctf/flag` 파일을 읽어 응답 맨 아래에 덧붙인다.
3. 단, 입력 문장에 한글/영문자가 섞이면 `qualifiesForFlag` 플래그가 내려가므로 **플래그 추가 로직이 비활성화**된다.  
   ```ts
   const containsHangul = /[\uac00-\ud7af]/.test(filteredMessage);
   const containsEnglish = /[A-Za-z]/.test(filteredMessage);
   const containsCjk = /[\u3040-\u30ff\u3400-\u4dbf\u4e00-\u9fff]/.test(filteredMessage);
   const qualifiesForFlag = containsCjk && !containsHangul && !containsEnglish;
   ...
   if (hasKeyword && qualifiesForFlag) {
     const flag = fs.readFileSync('/var/ctf/flag', 'utf-8').trim();
     reply = `${reply}\n\n${flag}`;
   }
   ```
4. 참가자는 한국어나 영어로 질문하면 평범한 답변만 받는다. **일본어/중국어 등 CJK 문자로 우회 프롬프트를 작성해 LLM이 `flag`라는 단어를 말하도록 유도해야** 플래그가 붙는다.

### 기대 시나리오
- 참가자가 평소 습관대로 한국어나 영어로 질문 → 챗봇은 정상 응답만 반환 (플래그 없음).
- 참가자가 “한국어/영어는 안 먹히는 것 같다”는 사실을 눈치챈 후, 일본어나 중국어 등 비라틴 문자로 프롬프트 인젝션을 시도.
- LLM이 `flag` 키워드를 언급하면 서버가 `/var/ctf/flag` 내용을 자동으로 덧붙여 전달 → 문제 해결.

### 학습 포인트
- **모델 응답은 신뢰할 수 없으며**, 응답 내용에 따라 서버가 민감 파일을 읽도록 설계하면 쉽게 악용된다.
- **블랙리스트 기반 필터링**(특정 언어/단어만 차단)은 우회가 가능하며, 통제하려는 조건과 실제 위험 구간이 분리돼 있을 때 더 취약해진다.
- LLM 기능을 서비스에 붙일 때는 출력 후 검증, 파일 접근 차단, 아웃바운드 필터링 등 추가 방어가 필수라는 메시지를 전달한다.


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bug2

## 설계 의도 

웹사이트의 구조상 

```json
// backend/src/middleware/auth.ts

// 정상 사용자 토큰
{
  "userId": "673fa1b2c9e8d4f3a1234567",
  "email": "user@example.com",
  "role": "user",
  "iat": 1732176242,
  "exp": 1732779042
}

// 관리자 토큰
{
  "userId": "admin_id_123",
  "email": "admin@hspace.io",
  "role": "admin",
  "debug": false,  
  "iat": 1732176242,
  "exp": 1732779042
}
```

- Debug Endpoint
    
    엔드포인트란 서버 기능 하나를 호출할 수 있는 URL이다. 
    
    debug 엔드포인트는 개발할 때 임시로 두는 디버그용 URL이다. 개발자가 시스템 정보를 확인하기 위해 만든 건데 배포할 때는 보안상 제거한다. 
    

- JWT 토큰
    
    이 토큰의 암호화된 문자열 안에는 중요한 내용이 다 들어있다. 
    
    서버는 이 토큰이 조작되었는지 확인하기 위해 JWT_SECRET으로 서명한다. 
    
    JWT는 단지 Base64 인코딩일 뿐 암호화는 아니다.
    

디버그 엔드포인트를 함께 배포 + None 알고리즘을 허용하는 라이브러리를 그대로 사용하면서 JWT토큰의 추가 검증을 하지 않도록 한다면 이를 취약점으로 설계할 수 있을 것이라고 생각했다. 

= 관리자 인증 우회 + 시스템 정보 접근

---

## 시나리오 

1. 정상 계정 생성 + JWT 토큰 획득 
2. JWT 토큰 구조 분석 (디코딩)
3. None 알고리즘 취약점 찾기 
4. admin role 위조
5. debug endpoint 접근
6. 플래그 추출  

---

## 부연 설명 

- JWT None 알고리즘
    
    서명 검증을 우회하는 방법을 찾다가 거의 대부분 JWT 라이브러리에서 개발자가 따로 코딩하지 않으면 기본적으로 허용되는 None 알고리즘을 알아냈다. 
    
    `alg: “none”` 으로 설정하면 우회가 가능하다고 한다. 
    
    그래서 페이로드를 짠다면 `role: "admin"` 으로 우회를 시도해볼 것

## exploit 스크립트 구조

    - `decode_jwt_payload()` : JWT base64 decoding
    - `create_none_token()` : None 알고리즘 토큰 위조
    
    1. 회원가입 
    2. 로그인하고 토큰 획득 
    3. JWT 페이로드 디코딩 
    4. none 알고리즘 토큰 위조 
    5. 그 위조된 토큰으로 debug endpoint 접근하여 정보 획득
    6. 플래그 추출


---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bug3

### 설계 의도

이 문제는 실제 환경에서 많이 발생하는 NoSQL Injection 취약점을 활용하였습니다.

```python
for (const key in obj) {
  if (typeof obj[key] === 'string') {
    if (pattern.test(obj[key])) {
      return true;
    }
  }
}
```

backend/src/middleware/security.ts 의 함수 중 sanitizeInput 함수가 값만 검사하고 키를 검사하지 않습니다

이를 통해 username[$ne]=nonexistent 등 키와 값으로 공격을 하는 NoSQL Injection을 사용해 문제를 설계할 수 있을 것 같아 만들게 되었습니다

우선 사용자의 입력을 받을 곳이 필요해서 또 다른 엔드포인트 /api/seats/check-reservation 를 만들어 취약하게 만들었습니다

또한 Express.js와 qs를 같이 사용해 { username: { $ne: 'nonexistent' } } 와 같이 객체를 만들어 공격하는 방법도 가능하게 만들었습니다

NoSQL Injection은 공격 로직이 다양하므로 꼭 { username: { $ne: 'nonexistent' } } 이것이 아니더라도 해당 취약점으로 계정 정보를 탈취하면 됩니다

### 풀이 과정

1. NoSQL Injection을 이용해 특수 ID ‘D5ngo2s_ID’의 계정 정보를 얻습니다
2. 이를 이용해 특수 계정(D5ngo2s_ID)으로 로그인합니다
3. 특수 계정 정보를 이용해 좌석을 아무거나 예약하면 flag를 획득할 수 있습니다

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
bug4

흔히 게시판… 하면 발생하는 취약점이 xss. 거기에 이미지 업로드 기능까지 있으니 **File Upload** 취약점까지 생길 수 있다고 통상 생각한다. path traversal, xss, file upload 등등 체이닝 취약점을 넣어서 여러가지 취약점 지식을 요구하고 xss를 발생시키기 위해 csp 정책을 우회해야 함으로써 이러한 경험들이 유익하다고 판단되었다.. exploit은 js코드로 진행하지만 svg파일로 하여 onload로 flag파일을 읽어오는 시나리오 또한 가능할 것 같다. 이러한 취약점들로 공격자들은

- xss가 서버 내부 api를 호출하는 도구로 활용될 수 있음을 배우고
- 연쇄 취약점이라는 방법론을 획득하고
- && → || 와 같은 단순 연산자 코드 하나로 서버가 취약해질 수 있음을 배운다.

## 시나리오

1. 파일 업로드 취약점 발견 (MimeType 검증 및 경로 치환 로직)
2. js나 svg로 flag파일을 읽어오는 코드 작성하여 파일 업로드
3. csp정책을 우회하기 위해 업로드된 파일을 불러오는 파일을 하나 더 작성하여 업로드
4. 플래그 탈취